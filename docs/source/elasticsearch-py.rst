=======================================================
Comparison with elasticsearch-py, the "Official Client"
=======================================================

pyelasticsearch was created before Elasticsearch-the-company provided its own
non-Java clients. At the time, there was no reliable, large-scale ES client
for Python: pyes was closest, but it suffered from pervasive weirdness, like
closing sockets in ``__del__`` and doing things which were obvious no-ops. We
adapted pyelasticsearch from an older, very simple client library and gave it
a complete API overhaul in 0.2, inspired by the principles of `poetic API
design <https://www.youtube.com/watch?v=JQYnFyG7A8c>`_: for example to make it
hard to accidentally delete all your indices.

Elasticsearch-the-company later created its own clients, with a strong draw
toward keeping them similar across languages for ease of support and
maintenance. The upside is that their libraries always support the latest and
greatest ES features, down to every last nook and cranny, because the relevant
parts are autogenerated from a generic API description language. The downside
is that some things end up less than Pythonic, conforming to the lowest common
feature set of supported languages.


Which Should You Use?
=====================

The official Python client borrows much design—and, in fact, quite a bit of
code—from pyelasticsearch. Starting in 0.8.0, pyelasticsearch returns the
favor, using elasticsearch-py's transport layer rather than maintaining its
own. The important differences remain at the API level.

In general, pyelasticsearch focuses on...

* Pythonic-ness

  pyelasticsearch is designed to feel at home in your program. For example, we
  strive for symmetry: creating an index is ``es.create()``, and searching one
  is ``es.search()``. In elasticsearch-py, however, creating an index is
  nested inside ``es.indices.create(<index name>)``, an artifact of code
  organization. Of course, the cost of design thought is that the project is
  slower moving.

* Good defaults and simple interfaces
 
  For example, there is only a single transport, HTTP, but it's the right one
  for almost all cases. Thrift, an alternative, yields a 15% speed boost but
  only when using many small requests. It doesn't help at all for bulk
  indexing, where speed is most often a concern, and, meanwhile it complicates
  troubleshooting, proxying, etc.

  Another example: we retry a query by default if a timeout occurs.

  The tradeoff is that we don't expose as many knobs to twiddle as the
  official client. If you have unusual needs, we might not be for you.
  Otherwise, enjoy having less verbose code.

* Safety

  If something fails, it always raises an exception, making it hard to
  accidentally ignore. elasticsearch-py doesn't always do this: you need to
  check for errors explicitly when using its bulk indexing helper.

* Better documentation

  You should never need to read the source code to figure out what to do.

  In order to twiddle many of the aforementioned knobs in elasticsearch-py,
  you must squirrel kwargs down through multiple undocumented layers, from
  constructor to constructor, until something finally understands them. It's
  often unclear what's public and what's private.

elasticsearch-py, meanwhile, focuses on...

* Comprehensive functionality

  It provides explicit hooks into every corner of ES and keeps up to date with
  ES releases. (Though you can always keep up using
  :ref:`forward-compatibility-kwargs` and
  :meth:`~pyelasticsearch.ElasticSearch.send_request()`.

* Cross-language homogeneity

  If you're accessing ES from multiple languages every day, you might enjoy
  having an API that looks similar across them.
